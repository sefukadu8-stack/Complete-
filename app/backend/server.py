Perfect! Now let me start building your complete e-commerce solution. I'll create the backend with MongoDB models for products, admin authentication, and all the features you need:
Action: bulk_file_creator ["/app/backend/server.py"] ['from fastapi import FastAPI, APIRouter, HTTPException, Depends, File, UploadFile, Form\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom dotenv import load_dotenv\nfrom starlette.middleware.cors import CORSMiddleware\nfrom motor.motor_asyncio import AsyncIOMotorClient\nimport os\nimport logging\nfrom pathlib import Path\nfrom pydantic import BaseModel, Field\nfrom typing import List, Optional, Dict, Any\nimport uuid\nfrom datetime import datetime, timedelta\nimport jwt\nimport hashlib\nimport base64\nfrom bson import ObjectId\n\nROOT_DIR = Path(__file__).parent\nload_dotenv(ROOT_DIR / \'.env\')\n\n# MongoDB connection\nmongo_url = os.environ[\'MONGO_URL\']\nclient = AsyncIOMotorClient(mongo_url)\ndb = client.get_database("aura_fashion_db")\n\n# Create the main app\napp = FastAPI(title="AURA FASHION API", description="E-commerce API for AURA FASHION")\n\n# Create a router with the /api prefix\napi_router = APIRouter(prefix="/api")\n\n# Security\nsecurity = HTTPBearer()\nSECRET_KEY = "your-secret-key-for-aura-fashion-2024"\n\n# Admin credentials (same as your original)\nADMIN_CREDENTIALS = {\n    "username": "kadusefu4@gmail.com",\n    "password": "sajjadkaduu"\n}\n\n# Models\nclass ProductBase(BaseModel):\n    name: str\n    description: str\n    full_description: Optional[str] = None\n    price: float\n    original_price: Optional[float] = None\n    category: str\n    sizes: List[str]\n    colors: Optional[List[str]] = []\n    badge: Optional[str] = None\n    rating: Optional[float] = 4.5\n    reviews: Optional[int] = 0\n    images: List[str] = []\n    features: Optional[List[str]] = []\n    fabric: Optional[str] = None\n    care: Optional[str] = "Machine wash cold"\n    featured: Optional[bool] = False\n    in_stock: Optional[bool] = True\n\nclass Product(ProductBase):\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    date_added: datetime = Field(default_factory=datetime.utcnow)\n    updated_at: datetime = Field(default_factory=datetime.utcnow)\n\nclass ProductCreate(ProductBase):\n    pass\n\nclass ProductUpdate(BaseModel):\n    name: Optional[str] = None\n    description: Optional[str] = None\n    full_description: Optional[str] = None\n    price: Optional[float] = None\n    original_price: Optional[float] = None\n    category: Optional[str] = None\n    sizes: Optional[List[str]] = None\n    colors: Optional[List[str]] = None\n    badge: Optional[str] = None\n    images: Optional[List[str]] = None\n    features: Optional[List[str]] = None\n    fabric: Optional[str] = None\n    care: Optional[str] = None\n    featured: Optional[bool] = None\n    in_stock: Optional[bool] = None\n\nclass AdminLogin(BaseModel):\n    username: str\n    password: str\n\nclass AdminToken(BaseModel):\n    access_token: str\n    token_type: str\n\nclass Settings(BaseModel):\n    store_name: str = "AURA FASHION"\n    store_tagline: str = "Premium Collection"\n    store_description: str = "Premium Kurta Collection celebrating traditional Indian fashion"\n    whatsapp_number: str = "+918780813692"\n    email: str = "sefudinkadu@gmail.com"\n    phone: str = "+91 8780813692"\n    address: str = "Online Store"\n    instagram_url: str = "https://instagram.com/aurafashion"\n    facebook_url: str = "https://facebook.com/aurafashion"\n    pinterest_url: str = "https://pinterest.com/aurafashion"\n    twitter_url: str = "https://twitter.com/aurafashion"\n    hero_title: str = "Discover Your Elegance"\n    hero_subtitle: str = "New Collection 2024"\n    hero_description: str = "Premium handcrafted kurta sets that blend traditional artistry with contemporary fashion"\n    about_title: str = "AURA FASHION Story"\n    about_description: str = "AURA FASHION represents the perfect fusion of traditional Indian craftsmanship and contemporary fashion"\n\nclass OrderItem(BaseModel):\n    product_id: str\n    product_name: str\n    size: str\n    color: Optional[str] = None\n    quantity: int\n    price: float\n\nclass Order(BaseModel):\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    items: List[OrderItem]\n    customer_name: str\n    phone: str\n    email: Optional[str] = None\n    address: str\n    city: str\n    state: str\n    pincode: str\n    payment_mode: str = "COD"\n    total_amount: float\n    status: str = "pending"\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n    whatsapp_sent: bool = False\n\nclass OrderCreate(BaseModel):\n    items: List[OrderItem]\n    customer_name: str\n    phone: str\n    email: Optional[str] = None\n    address: str\n    city: str\n    state: str\n    pincode: str\n    payment_mode: str = "COD"\n\n# Utility functions\ndef create_access_token(data: dict):\n    to_encode = data.copy()\n    expire = datetime.utcnow() + timedelta(hours=24)\n    to_encode.update({"exp": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm="HS256")\n    return encoded_jwt\n\ndef verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=["HS256"])\n        username: str = payload.get("sub")\n        if username is None:\n            raise HTTPException(status_code=401, detail="Invalid token")\n        return username\n    except jwt.PyJWTError:\n        raise HTTPException(status_code=401, detail="Invalid token")\n\n# Routes\n@api_router.post("/admin/login", response_model=AdminToken)\nasync def admin_login(credentials: AdminLogin):\n    if (credentials.username == ADMIN_CREDENTIALS["username"] and \n        credentials.password == ADMIN_CREDENTIALS["password"]):\n        access_token = create_access_token(data={"sub": credentials.username})\n        return {"access_token": access_token, "token_type": "bearer"}\n    raise HTTPException(status_code=401, detail="Invalid credentials")\n\n@api_router.get("/admin/verify")\nasync def verify_admin(username: str = Depends(verify_token)):\n    return {"message": "Valid admin token", "username": username}\n\n# Product routes\n@api_router.get("/products", response_model=List[Product])\nasync def get_products():\n    try:\n        products = await db.products.find().to_list(1000)\n        return [Product(**product) for product in products]\n    except Exception as e:\n        logging.error(f"Error getting products: {e}")\n        return []\n\n@api_router.get("/products/{product_id}", response_model=Product)\nasync def get_product(product_id: str):\n    product = await db.products.find_one({"id": product_id})\n    if not product:\n        raise HTTPException(status_code=404, detail="Product not found")\n    return Product(**product)\n\n@api_router.post("/admin/products", response_model=Product)\nasync def create_product(product: ProductCreate, admin: str = Depends(verify_token)):\n    product_dict = product.dict()\n    product_obj = Product(**product_dict)\n    \n    # Insert into database\n    await db.products.insert_one(product_obj.dict())\n    return product_obj\n\n@api_router.put("/admin/products/{product_id}", response_model=Product)\nasync def update_product(product_id: str, product_update: ProductUpdate, admin: str = Depends(verify_token)):\n    # Find existing product\n    existing_product = await db.products.find_one({"id": product_id})\n    if not existing_product:\n        raise HTTPException(status_code=404, detail="Product not found")\n    \n    # Update fields\n    update_data = product_update.dict(exclude_unset=True)\n    update_data["updated_at"] = datetime.utcnow()\n    \n    # Update in database\n    await db.products.update_one({"id": product_id}, {"$set": update_data})\n    \n    # Return updated product\n    updated_product = await db.products.find_one({"id": product_id})\n    return Product(**updated_product)\n\n@api_router.delete("/admin/products/{product_id}")\nasync def delete_product(product_id: str, admin: str = Depends(verify_token)):\n    result = await db.products.delete_one({"id": product_id})\n    if result.deleted_count == 0:\n        raise HTTPException(status_code=404, detail="Product not found")\n    return {"message": "Product deleted successfully"}\n\n# Settings routes\n@api_router.get("/settings", response_model=Settings)\nasync def get_settings():\n    settings = await db.settings.find_one() or {}\n    return Settings(**settings)\n\n@api_router.put("/admin/settings", response_model=Settings)\nasync def update_settings(settings: Settings, admin: str = Depends(verify_token)):\n    settings_dict = settings.dict()\n    await db.settings.replace_one({}, settings_dict, upsert=True)\n    return settings\n\n# Order routes\n@api_router.post("/orders", response_model=Order)\nasync def create_order(order: OrderCreate):\n    # Calculate total\n    total_amount = sum(item.price * item.quantity for item in order.items)\n    \n    order_dict = order.dict()\n    order_dict["total_amount"] = total_amount\n    order_obj = Order(**order_dict)\n    \n    # Insert into database\n    await db.orders.insert_one(order_obj.dict())\n    return order_obj\n\n@api_router.get("/admin/orders", response_model=List[Order])\nasync def get_orders(admin: str = Depends(verify_token)):\n    orders = await db.orders.find().sort("created_at", -1).to_list(1000)\n    return [Order(**order) for order in orders]\n\n@api_router.put("/admin/orders/{order_id}")\nasync def update_order_status(order_id: str, status: str, admin: str = Depends(verify_token)):\n    result = await db.orders.update_one({"id": order_id}, {"$set": {"status": status}})\n    if result.modified_count == 0:\n        raise HTTPException(status_code=404, detail="Order not found")\n    return {"message": "Order status updated"}\n\n# Search products\n@api_router.get("/products/search/{query}")\nasync def search_products(query: str):\n    try:\n        # Search in name, description, category, and fabric\n        products = await db.products.find({\n            "$or": [\n                {"name": {"$regex": query, "$options": "i"}},\n                {"description": {"$regex": query, "$options": "i"}},\n                {"category": {"$regex": query, "$options": "i"}},\n                {"fabric": {"$regex": query, "$options": "i"}}\n            ]\n        }).to_list(100)\n        return [Product(**product) for product in products]\n    except Exception as e:\n        logging.error(f"Error searching products: {e}")\n        return []\n\n# Filter products by category\n@api_router.get("/products/category/{category}")\nasync def get_products_by_category(category: str):\n    try:\n        products = await db.products.find({"category": category}).to_list(1000)\n        return [Product(**product) for product in products]\n    except Exception as e:\n        logging.error(f"Error getting products by category: {e}")\n        return []\n\n# Stats for admin dashboard\n@api_router.get("/admin/stats")\nasync def get_admin_stats(admin: str = Depends(verify_token)):\n    total_products = await db.products.count_documents({})\n    total_orders = await db.orders.count_documents({})\n    pending_orders = await db.orders.count_documents({"status": "pending"})\n    total_revenue = 0\n    \n    # Calculate total revenue\n    orders = await db.orders.find({"status": {"$in": ["completed", "delivered"]}}).to_list(1000)\n    total_revenue = sum(order.get("total_amount", 0) for order in orders)\n    \n    return {\n        "total_products": total_products,\n        "total_orders": total_orders,\n        "pending_orders": pending_orders,\n        "total_revenue": total_revenue,\n        "categories": ["festive", "casual", "party", "wedding", "traditional"]\n    }\n\n# Initialize with sample data\n@api_router.post("/admin/init-sample-data")\nasync def init_sample_data(admin: str = Depends(verify_token)):\n    # Check if products already exist\n    existing_products = await db.products.count_documents({})\n    if existing_products > 0:\n        return {"message": "Sample data already exists"}\n    \n    sample_products = [\n        {\n            "name": "Elegant Floral Kurta Set",\n            "description": "Beautiful floral printed kurta with matching palazzo",\n            "full_description": "This stunning kurta set features intricate floral prints with comfortable palazzo pants. Perfect for festive occasions.",\n            "price": 2499.0,\n            "original_price": 3999.0,\n            "category": "festive",\n            "sizes": ["S", "M", "L", "XL", "XXL"],\n            "colors": ["Pink", "Blue", "Green"],\n            "badge": "Bestseller",\n            "rating": 4.5,\n            "reviews": 127,\n            "images": [\n                "https://images.unsplash.com/photo-1583391733956-3750e0ff4e8b?w=400&h=500&fit=crop",\n                "https://images.unsplash.com/photo-1594633312681-425c7b97ccd1?w=400&h=500&fit=crop"\n            ],\n            "features": ["Premium Cotton Fabric", "Comfortable Fit", "Machine Washable", "Wrinkle Resistant"],\n            "fabric": "Premium Cotton",\n            "care": "Machine wash cold, tumble dry low",\n            "featured": True,\n            "in_stock": True\n        },\n        {\n            "name": "Traditional Silk Kurta",\n            "description": "Pure silk kurta with golden embroidery work",\n            "full_description": "Exquisite pure silk kurta with hand-embroidered golden work. Perfect for weddings and special occasions.",\n            "price": 4999.0,\n            "original_price": 6999.0,\n            "category": "wedding",\n            "sizes": ["S", "M", "L", "XL"],\n            "colors": ["Golden", "Maroon", "Royal Blue"],\n            "badge": "New",\n            "rating": 4.8,\n            "reviews": 89,\n            "images": [\n                "https://images.unsplash.com/photo-1583391733975-cd2e1b2b8e8c?w=400&h=500&fit=crop",\n                "https://images.unsplash.com/photo-1594633312681-425c7b97ccd1?w=400&h=500&fit=crop"\n            ],\n            "features": ["Pure Silk Fabric", "Hand Embroidered", "Premium Quality", "Traditional Design"],\n            "fabric": "Pure Silk",\n            "care": "Dry clean only",\n            "featured": True,\n            "in_stock": True\n        }\n    ]\n    \n    for product_data in sample_products:\n        product_obj = Product(**product_data)\n        await db.products.insert_one(product_obj.dict())\n    \n    # Initialize settings\n    settings_obj = Settings()\n    await db.settings.replace_one({}, settings_obj.dict(), upsert=True)\n    \n    return {"message": f"Sample data initialized with {len(sample_products)} products"}\n\n# Include the router in the main app\napp.include_router(api_router)\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_credentials=True,\n    allow_origins=os.environ.get(\'CORS_ORIGINS\', \'*\').split(\',\'),\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\'%(asctime)s - %(name)s - %(levelname)s - %(message)s\'\n)\nlogger = logging.getLogger(__name__)\n\n@app.on_event("shutdown")\nasync def shutdown_db_client():\n    client.close()\n\nif __name__ == "__main__":\n    import uvicorn\n    uvicorn.run(app, host="0.0.0.0", port=8001)']
Observation: Successfully wrote 1 files:
- /app/backend/server.py
